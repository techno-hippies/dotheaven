{
  "version": 3,
  "sources": ["../bundle-PHKify/checked-fetch.js", "../../../src/index.ts", "../../../../../../../../../../home/t42/.nvm/versions/node/v22.17.0/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../../../../../../../home/t42/.nvm/versions/node/v22.17.0/lib/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-PHKify/middleware-insertion-facade.js", "../../../../../../../../../../home/t42/.nvm/versions/node/v22.17.0/lib/node_modules/wrangler/templates/middleware/common.ts", "../bundle-PHKify/middleware-loader.entry.ts"],
  "sourceRoot": "/media/t42/th42/Code/dotheaven/services/heaven-resolver/.wrangler/tmp/dev-xf6QX7",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "/**\n * heaven-resolver \u2014 MusicBrainz API proxy with KV caching.\n *\n * Endpoints:\n *   GET  /recording/:mbid              \u2192 artist info from a recording MBID\n *   GET  /artist/:mbid                 \u2192 artist metadata (name, genres, bio, image)\n *   GET  /search/artist?q=             \u2192 search artists by name\n *   POST /resolve/batch                \u2192 batch resolve {artist, title} \u2192 MBIDs via MB search\n *   GET  /resolve/spotify-artist/:id   \u2192 Spotify artist ID \u2192 MB artist MBID via URL relation\n *\n * MusicBrainz rate limit: 1 req/sec with User-Agent identification.\n * Cache: KV with 30-day positive TTL, 1-hour negative TTL.\n */\n\ninterface Env {\n  CACHE: KVNamespace\n  MB_USER_AGENT: string\n  ENVIRONMENT: string\n}\n\n// \u2500\u2500 Cache TTLs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst CACHE_TTL_POSITIVE = 60 * 60 * 24 * 30 // 30 days\nconst CACHE_TTL_NEGATIVE = 60 * 60            // 1 hour\n\n// \u2500\u2500 Rate limiter (per-isolate, best-effort) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nlet lastMbRequest = 0\n\nasync function mbFetch(url: string, env: Env): Promise<Response> {\n  // Enforce ~1 req/sec to MusicBrainz\n  const now = Date.now()\n  const wait = Math.max(0, 1100 - (now - lastMbRequest))\n  if (wait > 0) await new Promise((r) => setTimeout(r, wait))\n  lastMbRequest = Date.now()\n\n  return fetch(url, {\n    headers: {\n      'User-Agent': env.MB_USER_AGENT,\n      Accept: 'application/json',\n    },\n  })\n}\n\n// \u2500\u2500 CORS headers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfunction corsHeaders(): Record<string, string> {\n  return {\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type',\n  }\n}\n\nfunction jsonResponse(data: unknown, status = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: { 'Content-Type': 'application/json', ...corsHeaders() },\n  })\n}\n\n// \u2500\u2500 Route handlers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/**\n * GET /recording/:mbid\n * Resolves a recording MBID to its artist(s).\n * Returns: { recording: { mbid, title }, artists: [{ mbid, name, sortName }] }\n */\nasync function handleRecording(mbid: string, env: Env): Promise<Response> {\n  const cacheKey = `recording:${mbid}`\n  const cached = await env.CACHE.get(cacheKey, 'json') as Record<string, unknown> | null\n  if (cached) {\n    // Follow cached redirects instead of returning raw {redirect: ...}\n    if (typeof cached.redirect === 'string') return handleRecording(cached.redirect, env)\n    return jsonResponse(cached)\n  }\n\n  const url = `https://musicbrainz.org/ws/2/recording/${mbid}?inc=artists&fmt=json`\n  const res = await mbFetch(url, env)\n\n  if (res.status === 404) {\n    const neg = { error: 'not_found', mbid }\n    await env.CACHE.put(cacheKey, JSON.stringify(neg), { expirationTtl: CACHE_TTL_NEGATIVE })\n    return jsonResponse(neg, 404)\n  }\n\n  // Handle MBID merge/redirect (MusicBrainz returns 301/302 for merged entities)\n  if (res.status >= 300 && res.status < 400) {\n    const location = res.headers.get('Location')\n    if (location) {\n      const newMbid = location.match(/recording\\/([a-f0-9-]{36})/)?.[1]\n      if (newMbid) {\n        const redirect = { redirect: newMbid }\n        await env.CACHE.put(cacheKey, JSON.stringify(redirect), { expirationTtl: CACHE_TTL_POSITIVE })\n        return handleRecording(newMbid, env)\n      }\n    }\n  }\n\n  if (!res.ok) {\n    return jsonResponse({ error: 'upstream_error', status: res.status }, 502)\n  }\n\n  const data = await res.json() as {\n    id: string\n    title: string\n    'artist-credit'?: Array<{\n      artist: { id: string; name: string; 'sort-name': string }\n    }>\n  }\n\n  const result = {\n    recording: { mbid: data.id, title: data.title },\n    artists: (data['artist-credit'] ?? []).map((ac) => ({\n      mbid: ac.artist.id,\n      name: ac.artist.name,\n      sortName: ac.artist['sort-name'],\n    })),\n  }\n\n  await env.CACHE.put(cacheKey, JSON.stringify(result), { expirationTtl: CACHE_TTL_POSITIVE })\n  return jsonResponse(result)\n}\n\n/**\n * GET /artist/:mbid\n * Returns artist metadata: name, genres, type, area, disambiguation, links.\n */\nasync function handleArtist(mbid: string, env: Env): Promise<Response> {\n  const cacheKey = `artist:${mbid}`\n  const cached = await env.CACHE.get(cacheKey, 'json') as Record<string, unknown> | null\n  if (cached) {\n    // Follow cached redirects instead of returning raw {redirect: ...}\n    if (typeof cached.redirect === 'string') return handleArtist(cached.redirect, env)\n    return jsonResponse(cached)\n  }\n\n  const url = `https://musicbrainz.org/ws/2/artist/${mbid}?inc=genres+url-rels&fmt=json`\n  const res = await mbFetch(url, env)\n\n  if (res.status === 404) {\n    const neg = { error: 'not_found', mbid }\n    await env.CACHE.put(cacheKey, JSON.stringify(neg), { expirationTtl: CACHE_TTL_NEGATIVE })\n    return jsonResponse(neg, 404)\n  }\n\n  if (res.status >= 300 && res.status < 400) {\n    const location = res.headers.get('Location')\n    if (location) {\n      const newMbid = location.match(/artist\\/([a-f0-9-]{36})/)?.[1]\n      if (newMbid) {\n        await env.CACHE.put(cacheKey, JSON.stringify({ redirect: newMbid }), { expirationTtl: CACHE_TTL_POSITIVE })\n        return handleArtist(newMbid, env)\n      }\n    }\n  }\n\n  if (!res.ok) {\n    return jsonResponse({ error: 'upstream_error', status: res.status }, 502)\n  }\n\n  const data = await res.json() as {\n    id: string\n    name: string\n    'sort-name': string\n    type?: string\n    disambiguation?: string\n    country?: string\n    area?: { name: string }\n    'life-span'?: { begin?: string; end?: string; ended?: boolean }\n    genres?: Array<{ name: string; count: number }>\n    relations?: Array<{\n      type: string\n      url?: { resource: string }\n    }>\n  }\n\n  // Extract useful links\n  const links: Record<string, string> = {}\n  for (const rel of data.relations ?? []) {\n    if (rel.url?.resource) {\n      if (rel.type === 'wikidata') links.wikidata = rel.url.resource\n      else if (rel.type === 'image') links.image = rel.url.resource\n      else if (rel.type === 'official homepage') links.website = rel.url.resource\n      else if (rel.type === 'social network') {\n        const u = rel.url.resource\n        if (u.includes('twitter.com') || u.includes('x.com')) links.twitter = u\n        else if (u.includes('instagram.com')) links.instagram = u\n        else if (u.includes('facebook.com')) links.facebook = u\n      }\n      else if (rel.type === 'streaming music' || rel.type === 'free streaming') {\n        const u = rel.url.resource\n        if (u.includes('spotify.com')) links.spotify = u\n        else if (u.includes('soundcloud.com')) links.soundcloud = u\n      }\n    }\n  }\n\n  const result = {\n    mbid: data.id,\n    name: data.name,\n    sortName: data['sort-name'],\n    type: data.type ?? null,\n    disambiguation: data.disambiguation ?? null,\n    country: data.country ?? null,\n    area: data.area?.name ?? null,\n    lifeSpan: data['life-span'] ?? null,\n    genres: (data.genres ?? [])\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10)\n      .map((g) => g.name),\n    links,\n  }\n\n  await env.CACHE.put(cacheKey, JSON.stringify(result), { expirationTtl: CACHE_TTL_POSITIVE })\n  return jsonResponse(result)\n}\n\n/**\n * GET /search/artist?q=name\n * Search MusicBrainz for artists by name. Returns top 5 matches.\n */\nasync function handleSearchArtist(query: string, env: Env): Promise<Response> {\n  if (!query || query.length < 2) {\n    return jsonResponse({ error: 'query too short' }, 400)\n  }\n\n  const cacheKey = `search:artist:${query.toLowerCase().trim()}`\n  const cached = await env.CACHE.get(cacheKey, 'json')\n  if (cached) return jsonResponse(cached)\n\n  const url = `https://musicbrainz.org/ws/2/artist/?query=${encodeURIComponent(query)}&limit=5&fmt=json`\n  const res = await mbFetch(url, env)\n\n  if (!res.ok) {\n    return jsonResponse({ error: 'upstream_error', status: res.status }, 502)\n  }\n\n  const data = await res.json() as {\n    artists: Array<{\n      id: string\n      name: string\n      'sort-name': string\n      score: number\n      type?: string\n      disambiguation?: string\n      country?: string\n    }>\n  }\n\n  const result = {\n    artists: (data.artists ?? []).map((a) => ({\n      mbid: a.id,\n      name: a.name,\n      sortName: a['sort-name'],\n      score: a.score,\n      type: a.type ?? null,\n      disambiguation: a.disambiguation ?? null,\n      country: a.country ?? null,\n    })),\n  }\n\n  // Cache searches for 24h (shorter \u2014 results may change with new releases)\n  await env.CACHE.put(cacheKey, JSON.stringify(result), { expirationTtl: 60 * 60 * 24 })\n  return jsonResponse(result)\n}\n\n// \u2500\u2500 Batch resolve: {artist, title} \u2192 MBIDs via MusicBrainz search \u2500\u2500\u2500\n\nconst MAX_BATCH_SIZE = 50\nconst MIN_SCORE = 80 // minimum MB search score to accept a match\n\ninterface ResolveItem {\n  artist: string\n  title: string\n  release?: string\n}\n\ninterface ResolveResult {\n  recording_mbid: string | null\n  recording_name: string | null\n  artist_mbids: string[]\n  artist_credit_name: string | null\n  release_mbid: string | null\n  release_name: string | null\n  score: number\n}\n\nconst EMPTY_RESULT: ResolveResult = {\n  recording_mbid: null,\n  recording_name: null,\n  artist_mbids: [],\n  artist_credit_name: null,\n  release_mbid: null,\n  release_name: null,\n  score: 0,\n}\n\n/** Sentinel: resolveOne hit a transient upstream error \u2014 don't cache. */\nconst TRANSIENT_ERROR = Symbol('transient')\n\n/**\n * Resolve a single (artist, title) pair via MusicBrainz recording search.\n * Uses Lucene query: `recording:\"title\" AND artist:\"artist\"`\n * Returns the top result if score >= MIN_SCORE, EMPTY_RESULT for genuine misses,\n * or TRANSIENT_ERROR if MB returned a server error (so we skip caching).\n */\nasync function resolveOne(item: ResolveItem, env: Env): Promise<ResolveResult | typeof TRANSIENT_ERROR> {\n  // Build Lucene query parts\n  const parts = [\n    `recording:\"${luceneEscape(item.title)}\"`,\n    `artist:\"${luceneEscape(item.artist)}\"`,\n  ]\n  if (item.release) {\n    parts.push(`release:\"${luceneEscape(item.release)}\"`)\n  }\n  const q = parts.join(' AND ')\n\n  const url = `https://musicbrainz.org/ws/2/recording/?query=${encodeURIComponent(q)}&limit=1&fmt=json`\n\n  let res: Response\n  try {\n    res = await mbFetch(url, env)\n  } catch {\n    return TRANSIENT_ERROR\n  }\n\n  // Server errors are transient \u2014 don't cache\n  if (res.status >= 500) return TRANSIENT_ERROR\n  if (!res.ok) return EMPTY_RESULT\n\n  const data = await res.json() as {\n    recordings?: Array<{\n      id: string\n      title: string\n      score: number\n      'artist-credit'?: Array<{\n        artist: { id: string; name: string }\n      }>\n      releases?: Array<{\n        id: string\n        title: string\n      }>\n    }>\n  }\n\n  const top = data.recordings?.[0]\n  if (!top || top.score < MIN_SCORE) return EMPTY_RESULT\n\n  return {\n    recording_mbid: top.id,\n    recording_name: top.title,\n    artist_mbids: (top['artist-credit'] ?? []).map((ac) => ac.artist.id),\n    artist_credit_name: (top['artist-credit'] ?? []).map((ac) => ac.artist.name).join(', ') || null,\n    release_mbid: top.releases?.[0]?.id ?? null,\n    release_name: top.releases?.[0]?.title ?? null,\n    score: top.score,\n  }\n}\n\n/**\n * POST /resolve/batch\n * Batch resolve recordings via MusicBrainz recording search.\n * Input:  { recordings: [{ artist, title, release? }] }\n * Output: { results: [ResolveResult] } \u2014 parallel array, null fields for misses\n *\n * Checks KV cache per item first, then resolves uncached items sequentially\n * (respecting MB's 1 req/sec rate limit).\n */\nasync function handleResolveBatch(request: Request, env: Env): Promise<Response> {\n  let body: { recordings?: unknown }\n  try {\n    body = await request.json() as { recordings?: unknown }\n  } catch {\n    return jsonResponse({ error: 'invalid JSON body' }, 400)\n  }\n\n  if (!Array.isArray(body.recordings) || body.recordings.length === 0) {\n    return jsonResponse({ error: 'recordings array required' }, 400)\n  }\n\n  if (body.recordings.length > MAX_BATCH_SIZE) {\n    return jsonResponse({ error: `max ${MAX_BATCH_SIZE} recordings per batch` }, 400)\n  }\n\n  const items = body.recordings as ResolveItem[]\n\n  // Validate\n  for (const item of items) {\n    if (!item.artist || !item.title) {\n      return jsonResponse({ error: 'each item needs artist and title' }, 400)\n    }\n  }\n\n  // Build cache keys (include release when present for more precise matches)\n  const cacheKeys = items.map((item) => {\n    let key = `resolve:${item.artist.toLowerCase().trim()}::${item.title.toLowerCase().trim()}`\n    if (item.release) key += `::${item.release.toLowerCase().trim()}`\n    return key\n  })\n\n  // Parallel KV lookups\n  const cached = await Promise.all(\n    cacheKeys.map((key) => env.CACHE.get(key, 'json') as Promise<ResolveResult | null>)\n  )\n\n  const results: ResolveResult[] = new Array(items.length)\n  const uncachedIndices: number[] = []\n\n  for (let i = 0; i < items.length; i++) {\n    if (cached[i] !== null) {\n      results[i] = cached[i]!\n    } else {\n      uncachedIndices.push(i)\n    }\n  }\n\n  // Resolve uncached items sequentially (MB rate limit: 1 req/sec)\n  for (const idx of uncachedIndices) {\n    const resolved = await resolveOne(items[idx], env)\n\n    // Transient upstream errors: return empty to client, skip caching\n    if (resolved === TRANSIENT_ERROR) {\n      results[idx] = EMPTY_RESULT\n      continue\n    }\n\n    results[idx] = resolved\n    const ttl = resolved.recording_mbid ? CACHE_TTL_POSITIVE : CACHE_TTL_NEGATIVE\n    await env.CACHE.put(cacheKeys[idx], JSON.stringify(resolved), { expirationTtl: ttl })\n  }\n\n  return jsonResponse({ results })\n}\n\n// \u2500\u2500 Spotify artist \u2192 MB artist MBID \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/**\n * GET /resolve/spotify-artist/:id\n * Resolves a Spotify artist ID to a MusicBrainz artist MBID via URL relation lookup.\n * Uses: https://musicbrainz.org/ws/2/url?resource=https://open.spotify.com/artist/{id}&fmt=json\n */\nasync function handleResolveSpotifyArtist(spotifyId: string, env: Env): Promise<Response> {\n  const cacheKey = `spotify-artist:${spotifyId}`\n  const cached = await env.CACHE.get(cacheKey, 'json')\n  if (cached) return jsonResponse(cached)\n\n  const spotifyUrl = `https://open.spotify.com/artist/${spotifyId}`\n  const url = `https://musicbrainz.org/ws/2/url?resource=${encodeURIComponent(spotifyUrl)}&inc=artist-rels&fmt=json`\n  const res = await mbFetch(url, env)\n\n  if (res.status === 404) {\n    const neg = { error: 'not_found', spotifyId }\n    await env.CACHE.put(cacheKey, JSON.stringify(neg), { expirationTtl: CACHE_TTL_NEGATIVE })\n    return jsonResponse(neg, 404)\n  }\n\n  if (!res.ok) {\n    return jsonResponse({ error: 'upstream_error', status: res.status }, 502)\n  }\n\n  const data = await res.json() as {\n    relations?: Array<{\n      type: string\n      direction: string\n      artist?: { id: string; name: string; 'sort-name': string }\n    }>\n  }\n\n  // Extract artist relation from the URL entity\n  const artistRel = data.relations?.find((r) => r.artist)\n  if (!artistRel?.artist) {\n    const neg = { error: 'no_artist_relation', spotifyId }\n    await env.CACHE.put(cacheKey, JSON.stringify(neg), { expirationTtl: CACHE_TTL_NEGATIVE })\n    return jsonResponse(neg, 404)\n  }\n\n  const result = {\n    mbid: artistRel.artist.id,\n    name: artistRel.artist.name,\n    sortName: artistRel.artist['sort-name'],\n    spotifyId,\n  }\n\n  await env.CACHE.put(cacheKey, JSON.stringify(result), { expirationTtl: CACHE_TTL_POSITIVE })\n  return jsonResponse(result)\n}\n\n// \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/** Escape special Lucene characters for MusicBrainz search queries. */\nfunction luceneEscape(s: string): string {\n  // Lucene special chars: + - && || ! ( ) { } [ ] ^ \" ~ * ? : \\ /\n  return s.replace(/([+\\-&|!(){}[\\]^\"~*?:\\\\/])/g, '\\\\$1')\n}\n\n// \u2500\u2500 Router \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nconst UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/\nconst SPOTIFY_ID_RE = /^[a-zA-Z0-9]{22}$/\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    if (request.method === 'OPTIONS') {\n      return new Response(null, { status: 204, headers: corsHeaders() })\n    }\n\n    const url = new URL(request.url)\n    const path = url.pathname\n\n    // POST routes\n    if (request.method === 'POST') {\n      if (path === '/resolve/batch') {\n        return handleResolveBatch(request, env)\n      }\n      return jsonResponse({ error: 'not found' }, 404)\n    }\n\n    // GET routes\n    if (request.method !== 'GET') {\n      return jsonResponse({ error: 'method not allowed' }, 405)\n    }\n\n    // GET /recording/:mbid\n    const recordingMatch = path.match(/^\\/recording\\/([a-f0-9-]{36})$/)\n    if (recordingMatch) {\n      const mbid = recordingMatch[1]\n      if (!UUID_RE.test(mbid)) return jsonResponse({ error: 'invalid mbid' }, 400)\n      return handleRecording(mbid, env)\n    }\n\n    // GET /artist/:mbid\n    const artistMatch = path.match(/^\\/artist\\/([a-f0-9-]{36})$/)\n    if (artistMatch) {\n      const mbid = artistMatch[1]\n      if (!UUID_RE.test(mbid)) return jsonResponse({ error: 'invalid mbid' }, 400)\n      return handleArtist(mbid, env)\n    }\n\n    // GET /search/artist?q=...\n    if (path === '/search/artist') {\n      const q = url.searchParams.get('q')\n      if (!q) return jsonResponse({ error: 'missing q parameter' }, 400)\n      return handleSearchArtist(q, env)\n    }\n\n    // GET /resolve/spotify-artist/:id\n    const spotifyMatch = path.match(/^\\/resolve\\/spotify-artist\\/([a-zA-Z0-9]+)$/)\n    if (spotifyMatch) {\n      const spotifyId = spotifyMatch[1]\n      if (!SPOTIFY_ID_RE.test(spotifyId)) return jsonResponse({ error: 'invalid spotify id' }, 400)\n      return handleResolveSpotifyArtist(spotifyId, env)\n    }\n\n    // Health check\n    if (path === '/' || path === '/health') {\n      return jsonResponse({ ok: true, service: 'heaven-resolver' })\n    }\n\n    return jsonResponse({ error: 'not found' }, 404)\n  },\n} satisfies ExportedHandler<Env>\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/media/t42/th42/Code/dotheaven/services/heaven-resolver/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/home/t42/.nvm/versions/node/v22.17.0/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/home/t42/.nvm/versions/node/v22.17.0/lib/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/media/t42/th42/Code/dotheaven/services/heaven-resolver/src/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/media/t42/th42/Code/dotheaven/services/heaven-resolver/.wrangler/tmp/bundle-PHKify/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/home/t42/.nvm/versions/node/v22.17.0/lib/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/media/t42/th42/Code/dotheaven/services/heaven-resolver/.wrangler/tmp/bundle-PHKify/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/media/t42/th42/Code/dotheaven/services/heaven-resolver/.wrangler/tmp/bundle-PHKify/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
