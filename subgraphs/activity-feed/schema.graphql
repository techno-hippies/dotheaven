# ── PostsV1 — Post existence + metadata pointer ───────────────────

type Post @entity(immutable: false) {
  id: ID!                      # postId (bytes32 hex) — unique per post
  creator: Bytes!              # wallet address
  contentType: Int!            # 0=text, 1=photo
  metadataUri: String!         # IPFS URI to IPA metadata
  ipfsHash: String             # IPFS CID extracted from metadataUri
  contentId: Bytes             # keccak256("heaven:content:" + ipfsHash) for clustering
  isAdult: Boolean!            # 18+ content flag
  likeCount: Int!              # total likes (incremented/decremented by EngagementV2)
  commentCount: Int!           # total comments
  flagCount: Int!              # total flags
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  translations: [Translation!]! @derivedFrom(field: "post")
  comments: [Comment!]! @derivedFrom(field: "post")
}

# ── EngagementV2 — Translations ─────────────────────────────────────

type Translation @entity(immutable: true) {
  id: ID!                      # "{postId}-{langCode}" — one translation per language per post
  post: Post!                  # link to post
  postId: Bytes!               # bytes32 post key
  langCode: String!            # ISO 639-1 code, e.g. "ja", "es"
  translator: Bytes!           # address that triggered the translation
  text: String!                # translated text
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ── EngagementV2 — Comments ─────────────────────────────────────────

type Comment @entity(immutable: true) {
  id: ID!                      # commentId (uint256)
  post: Post!                  # link to post
  postId: Bytes!               # bytes32 post key
  author: Bytes!               # comment author address
  text: String!                # comment text
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ── LyricsEngagementV1 — Song Lyrics Translations ─────────────────

type SongTranslation @entity(immutable: true) {
  id: ID!                      # "{txHash}-{logIndex}" — unique per event, query latest by ipId+lang
  ipId: Bytes!                 # Story Protocol IP Asset address (the song)
  langCode: String!            # ISO 639-1 code, e.g. "zh", "en"
  translator: Bytes!           # address that triggered the translation
  cid: String!                 # IPFS CID of translation JSON
  textHash: Bytes!             # SHA-256 hash of translated text
  byteLen: Int!                # UTF-8 byte length of translated text
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ── FollowV1 — Social follow graph ──────────────────────────────────

type Follow @entity(immutable: false) {
  id: ID!                      # "{follower}-{followee}"
  follower: Bytes!             # follower address
  followee: Bytes!             # followee address
  active: Boolean!             # true = following, false = unfollowed
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserFollowStats @entity(immutable: false) {
  id: ID!                      # user address hex (lowercase)
  followerCount: Int!
  followingCount: Int!
}

# ── ScrobbleV3 — Track Registry + Scrobble Events ─────────────────

type UserVerification @entity(immutable: false) {
  id: ID!                      # user address hex (lowercase)
  verifiedAt: BigInt!          # unix seconds (mirrored from Celo SelfProfileVerifier.verifiedAt)
  nationality: String          # ISO-3 country code (e.g. "USA")
  mirroredAt: BigInt!          # MegaETH block timestamp of the latest mirror tx
  transactionHash: Bytes!
}

type Track @entity(immutable: false) {
  id: ID!                      # trackId (bytes32 hex)
  title: String!               # display title (from contract state)
  artist: String!              # display artist (from contract state)
  album: String!               # display album (from contract state)
  kind: Int!                   # 1=MBID, 2=ipId, 3=meta
  payload: Bytes!              # raw derivation input
  metaHash: Bytes!             # keccak256(abi.encode(title, artist, album))
  coverCid: String             # IPFS CID for album art (set once via setTrackCover)
  durationSec: Int             # track duration in seconds (0 = unknown)
  scrobbleCountTotal: BigInt!  # pre-aggregated total scrobbles (all users)
  scrobbleCountVerified: BigInt! # pre-aggregated scrobbles from verified users at scrobble time
  registeredAt: BigInt!        # block timestamp
  blockNumber: BigInt!
  transactionHash: Bytes!
  scrobbles: [Scrobble!]! @derivedFrom(field: "track")
}

type Scrobble @entity(immutable: true) {
  id: ID!                      # "{txHash}-{logIndex}"
  user: Bytes!                 # wallet address
  track: Track!                # link to registered track
  timestamp: BigInt!           # play timestamp (unix seconds)
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserListeningStats @entity(immutable: false) {
  id: ID!                      # user address hex (lowercase)
  user: Bytes!                 # wallet address
  totalScrobbles: BigInt!      # total lifetime scrobbles from indexed history
  lastScrobbleAt: BigInt!      # unix seconds of most recent scrobble
  topArtist: String!           # top artist by scrobble count for this user
  topArtistScrobbleCount: BigInt! # listens for topArtist
  updatedAtBlock: BigInt!      # latest block that touched this row
}

type UserArtistStats @entity(immutable: false) {
  id: ID!                      # "{user}-{artistKey}"
  user: Bytes!                 # wallet address
  artistKey: String!           # normalized artist key (lowercase)
  artist: String!              # display artist label (latest seen)
  scrobbleCount: BigInt!       # lifetime listens for this user + artist
  lastScrobbleAt: BigInt!      # unix seconds of latest scrobble for this artist
  updatedAtBlock: BigInt!      # latest block that touched this row
}

# ── ContentRegistry — Filecoin content pointers + access control ──

type ContentEntry @entity(immutable: false) {
  id: ID!                        # contentId (bytes32 hex)
  trackId: Bytes!                # references ScrobbleV3 track registry
  owner: Bytes!                  # content uploader address
  datasetOwner: Bytes!           # Beam CDN host address
  pieceCid: Bytes!               # Filecoin piece CID
  algo: Int!                     # encryption algorithm enum
  active: Boolean!               # false = deactivated
  createdAt: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  accessGrants: [AccessGrant!]! @derivedFrom(field: "content")
}

type AccessGrant @entity(immutable: false) {
  id: ID!                        # "{contentId}-{grantee}"
  content: ContentEntry!
  grantee: Bytes!
  granted: Boolean!              # true = active grant, false = revoked
  updatedAt: BigInt!
  blockNumber: BigInt!
}
