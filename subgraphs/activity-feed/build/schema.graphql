# ── PostsV1 — Post existence + metadata pointer ───────────────────

type Post @entity(immutable: true) {
  id: ID!                      # postId (bytes32 hex) — unique per post
  creator: Bytes!              # wallet address
  contentType: Int!            # 0=text, 1=photo
  metadataUri: String!         # IPFS URI to IPA metadata
  ipfsHash: String             # IPFS CID extracted from metadataUri
  contentId: Bytes             # keccak256("heaven:content:" + ipfsHash) for clustering
  isAdult: Boolean!            # 18+ content flag
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ── ScrobbleV3 — Track Registry + Scrobble Events ─────────────────

type Track @entity(immutable: false) {
  id: ID!                      # trackId (bytes32 hex)
  title: String!               # display title (from contract state)
  artist: String!              # display artist (from contract state)
  kind: Int!                   # 1=MBID, 2=ipId, 3=meta
  payload: Bytes!              # raw derivation input
  metaHash: Bytes!             # keccak256(abi.encode(title, artist, album))
  coverCid: String             # IPFS CID for album art (set once via setTrackCover)
  durationSec: Int             # track duration in seconds (0 = unknown)
  registeredAt: BigInt!        # block timestamp
  blockNumber: BigInt!
  transactionHash: Bytes!
  scrobbles: [Scrobble!]! @derivedFrom(field: "track")
}

type Scrobble @entity(immutable: true) {
  id: ID!                      # "{txHash}-{logIndex}"
  user: Bytes!                 # wallet address
  track: Track!                # link to registered track
  timestamp: BigInt!           # play timestamp (unix seconds)
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ── ContentRegistry — Filecoin content pointers + access control ──

type ContentEntry @entity(immutable: false) {
  id: ID!                        # contentId (bytes32 hex)
  trackId: Bytes!                # references ScrobbleV3 track registry
  owner: Bytes!                  # content uploader address
  datasetOwner: Bytes!           # Beam CDN host address
  pieceCid: Bytes!               # Filecoin piece CID
  algo: Int!                     # encryption algorithm enum
  active: Boolean!               # false = deactivated
  createdAt: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  accessGrants: [AccessGrant!]! @derivedFrom(field: "content")
}

type AccessGrant @entity(immutable: false) {
  id: ID!                        # "{contentId}-{grantee}"
  content: ContentEntry!
  grantee: Bytes!
  granted: Boolean!              # true = active grant, false = revoked
  updatedAt: BigInt!
  blockNumber: BigInt!
}
