import{g,d as y,L as d,r as f}from"./index-gcSTJc4U.js";let r=null,a=null;function m(){return new Date(Date.now()+d.sessionExpirationMs).toISOString()}function x(){const t=[];for(let e=0;e<localStorage.length;e++){const n=localStorage.key(e);n&&n.startsWith(`lit-auth:${d.appName}:`)&&t.push(n)}for(const e of t)console.log("[Lit] Removing stale session key:",e),localStorage.removeItem(e);f(),r=null,a=null}async function l(t,e){const n=await g(),o=await y().createPkpAuthContext({authData:e,pkpPublicKey:t.publicKey,authConfig:{domain:typeof window<"u"?window.location.host:"localhost",statement:"Execute Lit Actions and sign messages",expiration:m(),resources:[["lit-action-execution","*"],["pkp-signing","*"],["access-control-condition-decryption","*"]]},litClient:n});return console.log("[Lit] PKP authContext created, keys:",Object.keys(o)),r=o,a=t.publicKey,o}async function K(t,e){if(r&&a===t.publicKey)return r;console.log("[Lit] Creating PKP auth context..."),console.log("[Lit] Input authData keys:",Object.keys(e)),console.log("[Lit] Input authData full:",e),console.log("[Lit] Input authData type:",typeof e),console.log("[Lit] Input authData has authMethodType:","authMethodType"in e),console.log("[Lit] Input authData has authSig:","authSig"in e),console.log("[Lit] Input authData has sessionSigs:","sessionSigs"in e);try{return await l(t,e)}catch(n){const s=n instanceof Error?n.message:"";if(s.includes("InvalidAuthSig")||s.includes("auth_sig passed is invalid")||s.includes("can't get auth context")||s.includes("Signature error")||s.includes("signature error")){console.warn("[Lit] Session expired, clearing stale session data and retrying..."),x();try{return await l(t,e)}catch(o){throw console.error("[Lit] Retry also failed:",o),new Error(`Failed to create PKP auth context after retry: ${o instanceof Error?o.message:"Unknown error"}`)}}throw console.error("[Lit] Failed to create PKP auth context:",n),new Error(`Failed to create PKP auth context: ${n instanceof Error?n.message:"Unknown error"}`)}}function w(){r=null,a=null}const u=!1;function P(t){if(t instanceof Error){const e=t.message.toLowerCase();return e.includes("encrypted payload decryption failed")||e.includes("invalid signature")||e.includes("session has expired")||e.includes("auth method verification failed")}return!1}class h extends Error{constructor(){super("Your session has expired. Please sign in again to continue."),this.name="SessionExpiredError"}}async function S(t,e,n){try{const c=await(await g()).executeJs({code:`(async () => {
      const sigShare = await Lit.Actions.ethPersonalSignMessageEcdsa({
        message: jsParams.message,
        publicKey: jsParams.publicKey,
        sigName: "sig",
      });
    })();`,authContext:e,jsParams:{message:n,publicKey:t.publicKey}});if(c.signatures&&c.signatures.sig){const i=c.signatures.sig;if(i.signature&&i.recoveryId!==void 0){const p=(i.recoveryId+27).toString(16).padStart(2,"0");return`0x${i.signature.startsWith("0x")?i.signature.slice(2):i.signature}${p}`}}throw new Error("No signature returned from Lit Action")}catch(s){throw console.error("[PKPSigner] Failed to sign message:",s),P(s)?(w(),new h):new Error(`Failed to sign message: ${s instanceof Error?s.message:"Unknown error"}`)}}const b=Object.freeze(Object.defineProperty({__proto__:null,SessionExpiredError:h,signMessageWithPKP:S},Symbol.toStringTag,{value:"Module"}));export{h as S,w as a,b,K as c,S as s};
